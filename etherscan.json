{"language":"Solidity","sources":{"contracts/transmuter/facets/Redeemer.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\nimport { SafeCast } from \"oz/utils/math/SafeCast.sol\";\nimport { SafeERC20 } from \"oz/token/ERC20/utils/SafeERC20.sol\";\nimport { Math } from \"oz/utils/math/Math.sol\";\n\nimport { IAgToken } from \"interfaces/IAgToken.sol\";\nimport { IRedeemer } from \"interfaces/IRedeemer.sol\";\n\nimport { AccessControlModifiers } from \"./AccessControlModifiers.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { LibHelpers } from \"../libraries/LibHelpers.sol\";\nimport { LibGetters } from \"../libraries/LibGetters.sol\";\nimport { LibManager } from \"../libraries/LibManager.sol\";\nimport { LibStorage as s } from \"../libraries/LibStorage.sol\";\nimport { LibWhitelist } from \"../libraries/LibWhitelist.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n/// @title Redeemer\n/// @author Angle Labs, Inc.\ncontract Redeemer is IRedeemer, AccessControlModifiers {\n    using SafeERC20 for IERC20;\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    event Redeemed(\n        uint256 amount,\n        address[] tokens,\n        uint256[] amounts,\n        address[] forfeitTokens,\n        address indexed from,\n        address indexed to\n    );\n    event NormalizerUpdated(uint256 newNormalizerValue);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   EXTERNAL ACTIONS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @inheritdoc IRedeemer\n    /// @dev The `minAmountOuts` list must reflect the amount of `tokens` returned\n    /// @dev In normal conditions, the amount of tokens outputted by this function should be the amount\n    /// of collateral assets supported by the system, following their order in the `collateralList`.\n    /// @dev If one collateral has its liquidity managed through strategies, then it's possible that this asset\n    /// has sub-collaterals with it. In this situation, these sub-collaterals may be sent during the redemption\n    /// process and the `minAmountOuts` will be bigger than the `collateralList` length. If there are 3 collateral\n    /// assets and the 2nd collateral asset in the list (at index 1) consists of 3 sub-collaterals, then the ordering\n    /// of the token list will be as follows:\n    /// `[collat 1, sub-collat 1 of collat 2, sub-collat 2 of collat 2, sub-collat 3 of collat 2, collat 3]`\n    /// @dev The list of tokens outputted (and hence the minimum length of the `minAmountOuts` list) can be obtained\n    /// by calling the `quoteRedemptionCurve` function\n    /// @dev Tokens requiring a whitelist must be forfeited if the redemption is to an address that is not in the\n    /// whitelist, otherwise this function reverts\n    /// @dev No approval is needed before calling this function\n    function redeem(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts\n    ) external returns (address[] memory tokens, uint256[] memory amounts) {\n        return _redeem(amount, receiver, deadline, minAmountOuts, new address[](0));\n    }\n\n    /// @inheritdoc IRedeemer\n    /// @dev Beware that if a token is given in the `forfeitTokens` list, the redemption will not try to send token\n    /// even if it has enough immediately available to send the amount\n    function redeemWithForfeit(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) external returns (address[] memory tokens, uint256[] memory amounts) {\n        return _redeem(amount, receiver, deadline, minAmountOuts, forfeitTokens);\n    }\n\n    /// @inheritdoc IRedeemer\n    /// @dev This function may be called by trusted addresses: these could be for instance savings contract\n    /// minting stablecoins when they notice a profit\n    function updateNormalizer(uint256 amount, bool increase) external returns (uint256) {\n        if (!LibDiamond.isGovernor(msg.sender) && s.transmuterStorage().isTrusted[msg.sender] == 0) revert NotTrusted();\n        return _updateNormalizer(amount, increase);\n    }\n\n    /// @inheritdoc IRedeemer\n    function quoteRedemptionCurve(\n        uint256 amount\n    ) external view returns (address[] memory tokens, uint256[] memory amounts) {\n        (tokens, amounts, ) = _quoteRedemptionCurve(amount);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   INTERNAL HELPERS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal function of the `redeem` function in the `Redeemer` contract\n    function _redeem(\n        uint256 amount,\n        address to,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) internal nonReentrant returns (address[] memory tokens, uint256[] memory amounts) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n\n        if (ts.isRedemptionLive == 0) revert Paused();\n        if (block.timestamp > deadline) revert TooLate();\n\n        uint256[] memory subCollateralsTracker;\n        (tokens, amounts, subCollateralsTracker) = _quoteRedemptionCurve(amount);\n        // Check that the provided slippage tokens length is identical to the redeem one\n        uint256 amountsLength = amounts.length;\n        if (amountsLength != minAmountOuts.length) revert InvalidLengths();\n        // Updating the normalizer enables to simultaneously and proportionally reduce the amount\n        // of stablecoins issued from each collateral without having to loop through each of them\n        _updateNormalizer(amount, false);\n\n        IAgToken(ts.agToken).burnSelf(amount, msg.sender);\n\n        address[] memory collateralListMem = ts.collateralList;\n        uint256 indexCollateral;\n        for (uint256 i; i < amountsLength; ++i) {\n            if (amounts[i] < minAmountOuts[i]) revert TooSmallAmountOut();\n            // If a token is in the `forfeitTokens` list, then it is not sent as part of the redemption process\n            if (amounts[i] > 0 && LibHelpers.checkList(tokens[i], forfeitTokens) < 0) {\n                Collateral storage collatInfo = ts.collaterals[collateralListMem[indexCollateral]];\n                if (collatInfo.onlyWhitelisted > 0 && !LibWhitelist.checkWhitelist(collatInfo.whitelistData, to))\n                    revert NotWhitelisted();\n                if (collatInfo.isManaged > 0)\n                    LibManager.release(tokens[i], to, amounts[i], collatInfo.managerData.config);\n                else IERC20(tokens[i]).safeTransfer(to, amounts[i]);\n            }\n            if (subCollateralsTracker[indexCollateral] - 1 <= i) ++indexCollateral;\n        }\n        emit Redeemed(amount, tokens, amounts, forfeitTokens, msg.sender, to);\n    }\n\n    /// @dev This function reverts if `stablecoinsIssued==0`, which is expected behavior as there is nothing to redeem\n    /// anyway in this case, or if the `amountBurnt` is greater than `stablecoinsIssued`\n    function _quoteRedemptionCurve(\n        uint256 amountBurnt\n    )\n        internal\n        view\n        returns (address[] memory tokens, uint256[] memory balances, uint256[] memory subCollateralsTracker)\n    {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint64 collatRatio;\n        uint256 stablecoinsIssued;\n        (collatRatio, stablecoinsIssued, tokens, balances, subCollateralsTracker) = LibGetters.getCollateralRatio();\n        if (amountBurnt > stablecoinsIssued) revert TooBigAmountIn();\n        int64[] memory yRedemptionCurveMem = ts.yRedemptionCurve;\n        uint64 penaltyFactor;\n        // If the protocol is under-collateralized, a penalty factor is applied to the returned amount of each asset\n        if (collatRatio < BASE_9) {\n            uint64[] memory xRedemptionCurveMem = ts.xRedemptionCurve;\n            penaltyFactor = uint64(LibHelpers.piecewiseLinear(collatRatio, xRedemptionCurveMem, yRedemptionCurveMem));\n        }\n\n        uint256 balancesLength = balances.length;\n        for (uint256 i; i < balancesLength; ++i) {\n            // The amount given for each token in reserves does not depend on the price of the tokens in reserve:\n            // it is a proportion of the balance for each token computed as the ratio between the stablecoins\n            // burnt relative to the amount of stablecoins issued.\n            // If the protocol is over-collateralized, the amount of each token given is inversely proportional\n            // to the collateral ratio.\n            balances[i] = collatRatio >= BASE_9\n                ? (amountBurnt * balances[i] * (uint64(yRedemptionCurveMem[yRedemptionCurveMem.length - 1]))) /\n                    (stablecoinsIssued * collatRatio)\n                : (amountBurnt * balances[i] * penaltyFactor) / (stablecoinsIssued * BASE_9);\n        }\n    }\n\n    /// @notice Updates the `normalizer` variable used to track stablecoins issued from each asset and globally\n    function _updateNormalizer(uint256 amount, bool increase) internal returns (uint256 newNormalizerValue) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint256 _normalizer = ts.normalizer;\n        uint256 _normalizedStables = ts.normalizedStables;\n        // In case of an increase, the update formula used is the simplified version of the formula below:\n        /*\n            _normalizer * (BASE_27 + BASE_27 * amount / stablecoinsIssued) / BASE_27\n             = _normalizer + (_normalizer * BASE_27 * amount * (BASE_27 / (_normalizedStables * normalizer))) / BASE_27\n             = _normalizer + BASE_27 * amount / _normalizedStables\n        */\n        if (increase) {\n            newNormalizerValue = _normalizer + (amount * BASE_27) / _normalizedStables;\n        } else {\n            newNormalizerValue = _normalizer - (amount * BASE_27) / _normalizedStables;\n        }\n        // If the `normalizer` gets too small or too big, it must be renormalized to later avoid the propagation of\n        // rounding errors, as well as overflows. In this case, the function has to iterate through all the\n        // supported collateral assets\n        if (newNormalizerValue <= BASE_18 || newNormalizerValue >= BASE_36) {\n            address[] memory collateralListMem = ts.collateralList;\n            uint256 collateralListLength = collateralListMem.length;\n            // For each asset, we store the actual amount of stablecoins issued based on the `newNormalizerValue`\n            // (and not a normalized value)\n            // We ensure to preserve the invariant `sum(collateralNewNormalizedStables) = normalizedStables`\n            uint128 newNormalizedStables;\n            for (uint256 i; i < collateralListLength; ++i) {\n                uint128 newCollateralNormalizedStable = ((uint256(\n                    ts.collaterals[collateralListMem[i]].normalizedStables\n                ) * newNormalizerValue) / BASE_27).toUint128();\n                newNormalizedStables += newCollateralNormalizedStable;\n                ts.collaterals[collateralListMem[i]].normalizedStables = uint216(newCollateralNormalizedStable);\n            }\n            ts.normalizedStables = newNormalizedStables;\n            newNormalizerValue = BASE_27;\n        }\n        ts.normalizer = newNormalizerValue.toUint128();\n        emit NormalizerUpdated(newNormalizerValue);\n    }\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"},"node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"},"node_modules/@openzeppelin/contracts/utils/math/Math.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)`  `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"},"contracts/interfaces/IAgToken.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\n\n/// @title IAgToken\n/// @author Angle Labs, Inc.\n/// @notice Interface for the stablecoins `AgToken` contracts\ninterface IAgToken is IERC20 {\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                              MINTER ROLE ONLY FUNCTIONS                                            \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Lets a whitelisted contract mint agTokens\n    /// @param account Address to mint to\n    /// @param amount Amount to mint\n    function mint(address account, uint256 amount) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address after being asked to by `sender`\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @param sender Address which requested the burn from `burner`\n    /// @dev This method is to be called by a contract with the minter right after being requested\n    /// to do so by a `sender` address willing to burn tokens from another `burner` address\n    /// @dev The method checks the allowance between the `sender` and the `burner`\n    function burnFrom(uint256 amount, address burner, address sender) external;\n\n    /// @notice Burns `amount` tokens from a `burner` address\n    /// @param amount Amount of tokens to burn\n    /// @param burner Address to burn from\n    /// @dev This method is to be called by a contract with a minter right on the AgToken after being\n    /// requested to do so by an address willing to burn tokens from its address\n    function burnSelf(uint256 amount, address burner) external;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                TREASURY ONLY FUNCTIONS                                             \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Adds a minter in the contract\n    /// @param minter Minter address to add\n    /// @dev Zero address checks are performed directly in the `Treasury` contract\n    function addMinter(address minter) external;\n\n    /// @notice Removes a minter from the contract\n    /// @param minter Minter address to remove\n    /// @dev This function can also be called by a minter wishing to revoke itself\n    function removeMinter(address minter) external;\n\n    /// @notice Sets a new treasury contract\n    /// @param _treasury New treasury address\n    function setTreasury(address _treasury) external;\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                  EXTERNAL FUNCTIONS                                                \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks whether an address has the right to mint agTokens\n    /// @param minter Address for which the minting right should be checked\n    /// @return Whether the address has the right to mint agTokens or not\n    function isMinter(address minter) external view returns (bool);\n\n    /// @notice Amount of decimals of the stablecoin\n    function decimals() external view returns (uint8);\n}\n"},"contracts/interfaces/IRedeemer.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\n/// @title IRedeemer\n/// @author Angle Labs, Inc.\ninterface IRedeemer {\n    /// @notice Redeems `amount` of stablecoins from the system\n    /// @param receiver Address which should be receiving the output tokens\n    /// @param deadline Timestamp before which the redemption should have occured\n    /// @param minAmountOuts Minimum amount of each token given back in the redemption to obtain\n    /// @return tokens List of tokens returned\n    /// @return amounts Amount given for each token in the `tokens` array\n    function redeem(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts\n    ) external returns (address[] memory tokens, uint256[] memory amounts);\n\n    /// @notice Same as the redeem function above with the additional feature to specify a list of `forfeitTokens` for\n    /// which the Transmuter system will not try to do a transfer to `receiver`.\n    function redeemWithForfeit(\n        uint256 amount,\n        address receiver,\n        uint256 deadline,\n        uint256[] memory minAmountOuts,\n        address[] memory forfeitTokens\n    ) external returns (address[] memory tokens, uint256[] memory amounts);\n\n    /// @notice Simulate the exact output that a redemption of `amount` of stablecoins would give at a given block\n    /// @return tokens List of tokens that would be given\n    /// @return amounts Amount that would be obtained for each token in the `tokens` array\n    function quoteRedemptionCurve(\n        uint256 amount\n    ) external view returns (address[] memory tokens, uint256[] memory amounts);\n\n    /// @notice Updates the normalizer variable by `amount`\n    function updateNormalizer(uint256 amount, bool increase) external returns (uint256);\n}\n"},"contracts/transmuter/facets/AccessControlModifiers.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { LibStorage as s, TransmuterStorage } from \"../libraries/LibStorage.sol\";\nimport \"../../utils/Errors.sol\";\nimport \"../../utils/Constants.sol\";\n\n/// @title AccessControlModifiers\n/// @author Angle Labs, Inc.\ncontract AccessControlModifiers {\n    /// @notice Checks whether the `msg.sender` has the governor role\n    modifier onlyGovernor() {\n        if (!LibDiamond.isGovernor(msg.sender)) revert NotGovernor();\n        _;\n    }\n\n    /// @notice Checks whether the `msg.sender` has the guardian role\n    modifier onlyGuardian() {\n        if (!LibDiamond.isGovernorOrGuardian(msg.sender)) revert NotGovernorOrGuardian();\n        _;\n    }\n\n    /// @notice Prevents a contract from calling itself, directly or indirectly\n    /// @dev This implementation is an adaptation of the OpenZepellin `ReentrancyGuard` for the purpose of this\n    /// Diamond Proxy system. The base implementation can be found here\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol\n    modifier nonReentrant() {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        // Reentrant protection\n        // On the first call, `ts.statusReentrant` will be `NOT_ENTERED`\n        if (ts.statusReentrant == ENTERED) revert ReentrantCall();\n        // Any calls to the `nonReentrant` modifier after this point will fail\n        ts.statusReentrant = ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see https://eips.ethereum.org/EIPS/eip-2200)\n        ts.statusReentrant = NOT_ENTERED;\n    }\n}\n"},"contracts/transmuter/libraries/LibDiamond.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport { LibStorage as s } from \"./LibStorage.sol\";\n\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n/// @title LibDiamond\n/// @author Angle Labs, Inc.\n/// @notice Helper library to deal with diamond proxies.\n/// @dev Reference: EIP-2535 Diamonds\n/// @dev Forked from https://github.com/mudgen/diamond-3/blob/master/contracts/libraries/LibDiamond.sol by mudgen\nlibrary LibDiamond {\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                  INTERNAL FUNCTIONS                                                \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Checks whether `admin` has the governor role\n    function isGovernor(address admin) internal view returns (bool) {\n        return s.diamondStorage().accessControlManager.isGovernor(admin);\n    }\n\n    /// @notice Checks whether `admin` has the guardian role\n    function isGovernorOrGuardian(address admin) internal view returns (bool) {\n        return s.diamondStorage().accessControlManager.isGovernorOrGuardian(admin);\n    }\n\n    /// @notice Internal function version of `diamondCut`\n    function diamondCut(FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        uint256 diamondCutLength = _diamondCut.length;\n        for (uint256 facetIndex; facetIndex < diamondCutLength; facetIndex++) {\n            bytes4[] memory functionSelectors = _diamondCut[facetIndex].functionSelectors;\n            address facetAddress = _diamondCut[facetIndex].facetAddress;\n\n            if (functionSelectors.length == 0) {\n                revert NoSelectorsProvidedForFacetForCut(facetAddress);\n            }\n\n            FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == FacetCutAction.Add) {\n                _addFunctions(facetAddress, functionSelectors);\n            } else if (action == FacetCutAction.Replace) {\n                _replaceFunctions(facetAddress, functionSelectors);\n            } else if (action == FacetCutAction.Remove) {\n                _removeFunctions(facetAddress, functionSelectors);\n            }\n        }\n\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        _initializeDiamondCut(_init, _calldata);\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   PRIVATE FUNCTIONS                                                \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Does a delegate call on `_init` with `_calldata`\n    function _initializeDiamondCut(address _init, bytes memory _calldata) private {\n        if (_init == address(0)) {\n            return;\n        }\n        _enforceHasContractCode(_init);\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    /// @notice Adds a new function to the diamond proxy\n    /// @dev Reverts if selectors are already existing\n    function _addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) private {\n        if (_facetAddress == address(0)) {\n            revert CannotAddSelectorsToZeroAddress(_functionSelectors);\n        }\n        DiamondStorage storage ds = s.diamondStorage();\n        uint16 selectorCount = uint16(ds.selectors.length);\n        _enforceHasContractCode(_facetAddress);\n        uint256 functionSelectorsLength = _functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorInfo[selector].facetAddress;\n            if (oldFacetAddress != address(0)) {\n                revert CannotAddFunctionToDiamondThatAlreadyExists(selector);\n            }\n            ds.selectorInfo[selector] = FacetInfo(_facetAddress, selectorCount);\n            ds.selectors.push(selector);\n            selectorCount++;\n        }\n    }\n\n    /// @notice Upgrades a function in the diamond proxy\n    /// @dev Reverts if selectors do not already exist\n    function _replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) private {\n        DiamondStorage storage ds = s.diamondStorage();\n        if (_facetAddress == address(0)) {\n            revert CannotReplaceFunctionsFromFacetWithZeroAddress(_functionSelectors);\n        }\n        _enforceHasContractCode(_facetAddress);\n        uint256 functionSelectorsLength = _functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorInfo[selector].facetAddress;\n            // Can't replace immutable functions -- functions defined directly in the diamond in this case\n            if (oldFacetAddress == address(this)) {\n                revert CannotReplaceImmutableFunction(selector);\n            }\n            if (oldFacetAddress == _facetAddress) {\n                revert CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(selector);\n            }\n            if (oldFacetAddress == address(0)) {\n                revert CannotReplaceFunctionThatDoesNotExists(selector);\n            }\n            // Replace old facet address\n            ds.selectorInfo[selector].facetAddress = _facetAddress;\n        }\n    }\n\n    /// @notice Removes a function in the diamond proxy\n    /// @dev Reverts if selectors do not already exist\n    function _removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) private {\n        DiamondStorage storage ds = s.diamondStorage();\n        uint256 selectorCount = ds.selectors.length;\n        if (_facetAddress != address(0)) {\n            revert RemoveFacetAddressMustBeZeroAddress(_facetAddress);\n        }\n        uint256 functionSelectorsLength = _functionSelectors.length;\n        for (uint256 selectorIndex; selectorIndex < functionSelectorsLength; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            FacetInfo memory oldFacetAddressAndSelectorPosition = ds.selectorInfo[selector];\n            if (oldFacetAddressAndSelectorPosition.facetAddress == address(0)) {\n                revert CannotRemoveFunctionThatDoesNotExist(selector);\n            }\n\n            // Can't remove immutable functions -- functions defined directly in the diamond\n            if (oldFacetAddressAndSelectorPosition.facetAddress == address(this)) {\n                revert CannotRemoveImmutableFunction(selector);\n            }\n            // Replace selector with last selector\n            selectorCount--;\n            if (oldFacetAddressAndSelectorPosition.selectorPosition != selectorCount) {\n                bytes4 lastSelector = ds.selectors[selectorCount];\n                ds.selectors[oldFacetAddressAndSelectorPosition.selectorPosition] = lastSelector;\n                ds.selectorInfo[lastSelector].selectorPosition = oldFacetAddressAndSelectorPosition.selectorPosition;\n            }\n            // Delete last selector\n            ds.selectors.pop();\n            delete ds.selectorInfo[selector];\n        }\n    }\n\n    /// @notice Checks that an address has a non void bytecode\n    function _enforceHasContractCode(address _contract) private view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        if (contractSize == 0) {\n            revert ContractHasNoCode();\n        }\n    }\n}\n"},"contracts/transmuter/libraries/LibHelpers.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.19;\n\nimport { Math } from \"oz/utils/math/Math.sol\";\n\nimport \"../Storage.sol\";\n\n/// @title LibHelpers\n/// @author Angle Labs, Inc.\nlibrary LibHelpers {\n    /// @notice Rebases the units of `amount` from `fromDecimals` to `toDecimals`\n    function convertDecimalTo(uint256 amount, uint8 fromDecimals, uint8 toDecimals) internal pure returns (uint256) {\n        if (fromDecimals > toDecimals) return amount / 10 ** (fromDecimals - toDecimals);\n        else if (fromDecimals < toDecimals) return amount * 10 ** (toDecimals - fromDecimals);\n        else return amount;\n    }\n\n    /// @notice Checks whether a `token` is in a list `tokens` and returns the index of the token in the list\n    /// or -1 in the other case\n    function checkList(address token, address[] memory tokens) internal pure returns (int256) {\n        uint256 tokensLength = tokens.length;\n        for (uint256 i; i < tokensLength; ++i) {\n            if (token == tokens[i]) return int256(i);\n        }\n        return -1;\n    }\n\n    /// @notice Searches a sorted `array` and returns the first index that contains a value strictly greater\n    /// (or lower if increasingArray is false) to `element` minus 1\n    /// @dev If no such index exists (i.e. all values in the array are strictly lesser/greater than `element`),\n    /// either array length minus 1, or 0 are returned\n    /// @dev The time complexity of the search is O(log n).\n    /// @dev Inspired from OpenZeppelin Contracts v4.4.1:\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Arrays.sol\n    /// @dev Modified by Angle Labs to support `uint64`, monotonous arrays and exclusive upper bounds\n    function findLowerBound(\n        bool increasingArray,\n        uint64[] memory array,\n        uint64 normalizerArray,\n        uint64 element\n    ) internal pure returns (uint256) {\n        if (array.length == 0) {\n            return 0;\n        }\n        uint256 low = 1;\n        uint256 high = array.length;\n\n        if (\n            (increasingArray && array[high - 1] * normalizerArray <= element) ||\n            (!increasingArray && array[high - 1] * normalizerArray >= element)\n        ) return high - 1;\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds down (it does integer division with truncation).\n            if (increasingArray ? array[mid] * normalizerArray > element : array[mid] * normalizerArray < element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound.\n        // `low - 1` is the inclusive lower bound.\n        return low - 1;\n    }\n\n    /// @notice Evaluates for `x` a piecewise linear function defined with the breaking points in the arrays\n    /// `xArray` and `yArray`\n    /// @dev The values in the `xArray` must be increasing\n    function piecewiseLinear(uint64 x, uint64[] memory xArray, int64[] memory yArray) internal pure returns (int64) {\n        uint256 indexLowerBound = findLowerBound(true, xArray, 1, x);\n        if (indexLowerBound == 0 && x < xArray[0]) return yArray[0];\n        else if (indexLowerBound == xArray.length - 1) return yArray[xArray.length - 1];\n        return\n            yArray[indexLowerBound] +\n            ((yArray[indexLowerBound + 1] - yArray[indexLowerBound]) * int64(x - xArray[indexLowerBound])) /\n            int64(xArray[indexLowerBound + 1] - xArray[indexLowerBound]);\n    }\n}\n"},"contracts/transmuter/libraries/LibGetters.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\nimport { Math } from \"oz/utils/math/Math.sol\";\nimport { SafeCast } from \"oz/utils/math/SafeCast.sol\";\n\nimport { LibHelpers } from \"./LibHelpers.sol\";\nimport { LibManager } from \"./LibManager.sol\";\nimport { LibOracle } from \"./LibOracle.sol\";\nimport { LibStorage as s } from \"./LibStorage.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../Storage.sol\";\n\n/// @title LibGetters\n/// @author Angle Labs, Inc.\nlibrary LibGetters {\n    using Math for uint256;\n    using SafeCast for uint256;\n\n    /// @notice Internal version of the `getCollateralRatio` function with additional return values like `tokens` that\n    /// is the list of tokens supported by the system, or `balances` which is the amount of each token in `tokens`\n    /// controlled by the protocol\n    /// @dev In case some collaterals support external strategies (`isManaged>0`), this list may be bigger\n    /// than the `collateralList`\n    /// @dev `subCollateralsTracker` is an array which gives for each collateral asset in the collateral list an\n    /// accumulator helping to recompute the amount of sub-collateral for each collateral. If the array is:\n    /// [1,4,5], this means that the collateral with index 1 in the `collateralsList` has 4-1=3 sub-collaterals.\n    function getCollateralRatio()\n        internal\n        view\n        returns (\n            uint64 collatRatio,\n            uint256 stablecoinsIssued,\n            address[] memory tokens,\n            uint256[] memory balances,\n            uint256[] memory subCollateralsTracker\n        )\n    {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        uint256 totalCollateralization;\n        address[] memory collateralList = ts.collateralList;\n        uint256 collateralListLength = collateralList.length;\n        uint256 subCollateralsAmount;\n        // Building the `subCollateralsTracker` array which is useful when later sending the tokens as part of the\n        // redemption\n        subCollateralsTracker = new uint256[](collateralListLength);\n        for (uint256 i; i < collateralListLength; ++i) {\n            if (ts.collaterals[collateralList[i]].isManaged == 0) ++subCollateralsAmount;\n            else subCollateralsAmount += ts.collaterals[collateralList[i]].managerData.subCollaterals.length;\n            subCollateralsTracker[i] = subCollateralsAmount;\n        }\n        balances = new uint256[](subCollateralsAmount);\n        tokens = new address[](subCollateralsAmount);\n\n        {\n            uint256 countCollat;\n            for (uint256 i; i < collateralListLength; ++i) {\n                Collateral storage collateral = ts.collaterals[collateralList[i]];\n                uint256 collateralBalance; // Will be either the balance or the value of assets managed\n                if (collateral.isManaged > 0) {\n                    // If a collateral is managed, the balances of the sub-collaterals cannot be directly obtained by\n                    // calling `balanceOf` of the sub-collaterals\n                    uint256[] memory subCollateralsBalances;\n                    (subCollateralsBalances, collateralBalance) = LibManager.totalAssets(collateral.managerData.config);\n                    uint256 numSubCollats = subCollateralsBalances.length;\n                    for (uint256 k; k < numSubCollats; ++k) {\n                        tokens[countCollat + k] = address(collateral.managerData.subCollaterals[k]);\n                        balances[countCollat + k] = subCollateralsBalances[k];\n                    }\n                    countCollat += numSubCollats;\n                } else {\n                    collateralBalance = IERC20(collateralList[i]).balanceOf(address(this));\n                    tokens[countCollat] = collateralList[i];\n                    balances[countCollat++] = collateralBalance;\n                }\n                uint256 oracleValue = LibOracle.readRedemption(collateral.oracleConfig);\n                totalCollateralization +=\n                    (oracleValue * LibHelpers.convertDecimalTo(collateralBalance, collateral.decimals, 18)) /\n                    BASE_18;\n            }\n        }\n        // The `stablecoinsIssued` value need to be rounded up because it is then used as a divizer when computing\n        // the `collatRatio`\n        stablecoinsIssued = uint256(ts.normalizedStables).mulDiv(ts.normalizer, BASE_27, Math.Rounding.Up);\n        if (stablecoinsIssued > 0) {\n            collatRatio = (totalCollateralization.mulDiv(BASE_9, stablecoinsIssued, Math.Rounding.Up)).toUint64();\n        } else collatRatio = type(uint64).max;\n    }\n}\n"},"contracts/transmuter/libraries/LibManager.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { IManager } from \"interfaces/IManager.sol\";\n\nimport \"../Storage.sol\";\n\n/// @title LibManager\n/// @author Angle Labs, Inc.\n/// @dev Managed collateral assets may be handled through external smart contracts or directly through this library\n/// @dev There is no implementation at this point for a managed collateral handled through this library, and\n/// a new specific `ManagerType` would need to be added in this case\nlibrary LibManager {\n    /// @notice Checks to which address managed funds must be transferred\n    function transferRecipient(bytes memory config) internal view returns (address recipient) {\n        (ManagerType managerType, bytes memory data) = parseManagerConfig(config);\n        recipient = address(this);\n        if (managerType == ManagerType.EXTERNAL) return abi.decode(data, (address));\n    }\n\n    /// @notice Performs a transfer of `token` for a collateral that is managed to a `to` address\n    /// @dev `token` may not be the actual collateral itself, as some collaterals have subcollaterals associated\n    /// with it\n    /// @dev Eventually pulls funds from strategies\n    function release(address token, address to, uint256 amount, bytes memory config) internal {\n        (ManagerType managerType, bytes memory data) = parseManagerConfig(config);\n        if (managerType == ManagerType.EXTERNAL) abi.decode(data, (IManager)).release(token, to, amount);\n    }\n\n    /// @notice Gets the balances of all the tokens controlled through `managerData`\n    /// @return balances An array of size `subCollaterals` with current balances of all subCollaterals\n    /// including the one corresponding to the `managerData` given\n    /// @return totalValue The value of all the `subCollaterals` in `collateral`\n    /// @dev `subCollaterals` must always have as first token (index 0) the collateral itself\n    function totalAssets(bytes memory config) internal view returns (uint256[] memory balances, uint256 totalValue) {\n        (ManagerType managerType, bytes memory data) = parseManagerConfig(config);\n        if (managerType == ManagerType.EXTERNAL) return abi.decode(data, (IManager)).totalAssets();\n    }\n\n    /// @notice Calls a hook if needed after new funds have been transfered to a manager\n    function invest(uint256 amount, bytes memory config) internal {\n        (ManagerType managerType, bytes memory data) = parseManagerConfig(config);\n        if (managerType == ManagerType.EXTERNAL) abi.decode(data, (IManager)).invest(amount);\n    }\n\n    /// @notice Returns available underlying tokens, for instance if liquidity is fully used and\n    /// not withdrawable the function will return 0\n    function maxAvailable(bytes memory config) internal view returns (uint256 available) {\n        (ManagerType managerType, bytes memory data) = parseManagerConfig(config);\n        if (managerType == ManagerType.EXTERNAL) return abi.decode(data, (IManager)).maxAvailable();\n    }\n\n    /// @notice Decodes the `managerData` associated to a collateral\n    function parseManagerConfig(\n        bytes memory config\n    ) internal pure returns (ManagerType managerType, bytes memory data) {\n        (managerType, data) = abi.decode(config, (ManagerType, bytes));\n    }\n}\n"},"contracts/transmuter/libraries/LibStorage.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport \"../../utils/Constants.sol\";\nimport { DiamondStorage, ImplementationStorage, TransmuterStorage } from \"../Storage.sol\";\n\n/// @title LibStorage\n/// @author Angle Labs, Inc.\nlibrary LibStorage {\n    /// @notice Returns the storage struct stored at the `DIAMOND_STORAGE_POSITION` slot\n    /// @dev This struct handles the logic of the different facets used in the diamond proxy\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    /// @notice Returns the storage struct stored at the `TRANSMUTER_STORAGE_POSITION` slot\n    /// @dev This struct handles the particular logic of the Transmuter system\n    function transmuterStorage() internal pure returns (TransmuterStorage storage ts) {\n        bytes32 position = TRANSMUTER_STORAGE_POSITION;\n        assembly {\n            ts.slot := position\n        }\n    }\n\n    /// @notice Returns the storage struct stored at the `IMPLEMENTATION_STORAGE_POSITION` slot\n    /// @dev This struct handles the logic for making the contract easily usable on Etherscan\n    function implementationStorage() internal pure returns (ImplementationStorage storage ims) {\n        bytes32 position = IMPLEMENTATION_STORAGE_POSITION;\n        assembly {\n            ims.slot := position\n        }\n    }\n}\n"},"contracts/transmuter/libraries/LibWhitelist.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { IKeyringGuard } from \"interfaces/external/keyring/IKeyringGuard.sol\";\n\nimport { LibStorage as s } from \"./LibStorage.sol\";\n\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n/// @title LibWhitelist\n/// @author Angle Labs, Inc.\nlibrary LibWhitelist {\n    /// @notice Checks whether `sender` is whitelisted for a collateral with `whitelistData`\n    function checkWhitelist(bytes memory whitelistData, address sender) internal returns (bool) {\n        (WhitelistType whitelistType, bytes memory data) = abi.decode(whitelistData, (WhitelistType, bytes));\n        if (s.transmuterStorage().isWhitelistedForType[whitelistType][sender] > 0) return true;\n        if (data.length != 0) {\n            if (whitelistType == WhitelistType.BACKED) {\n                address keyringGuard = abi.decode(data, (address));\n                if (keyringGuard != address(0)) return IKeyringGuard(keyringGuard).isAuthorized(address(this), sender);\n            }\n        }\n        return false;\n    }\n}\n"},"contracts/utils/Constants.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\nimport { ICbETH } from \"interfaces/external/coinbase/ICbETH.sol\";\nimport { ISfrxETH } from \"interfaces/external/frax/ISfrxETH.sol\";\nimport { IStETH } from \"interfaces/external/lido/IStETH.sol\";\nimport { IRETH } from \"interfaces/external/rocketPool/IRETH.sol\";\n\n/*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                 STORAGE SLOTS                                                  \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n/// @dev Storage position of `DiamondStorage` structure\n/// @dev Equals `keccak256(\"diamond.standard.diamond.storage\") - 1`\nbytes32 constant DIAMOND_STORAGE_POSITION = 0xc8fcad8db84d3cc18b4c41d551ea0ee66dd599cde068d998e57d5e09332c131b;\n\n/// @dev Storage position of `TransmuterStorage` structure\n/// @dev Equals `keccak256(\"diamond.standard.transmuter.storage\") - 1`\nbytes32 constant TRANSMUTER_STORAGE_POSITION = 0xc1f2f38dde3351ac0a64934139e816326caa800303a1235dc53707d0de05d8bd;\n\n/// @dev Storage position of `ImplementationStorage` structure\n/// @dev Equals `keccak256(\"eip1967.proxy.implementation\") - 1`\nbytes32 constant IMPLEMENTATION_STORAGE_POSITION = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n/*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                     MATHS                                                      \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\nuint256 constant BASE_6 = 1e6;\nuint256 constant BASE_8 = 1e8;\nuint256 constant BASE_9 = 1e9;\nuint256 constant BASE_12 = 1e12;\nuint256 constant BASE_18 = 1e18;\nuint256 constant HALF_BASE_27 = 1e27 / 2;\nuint256 constant BASE_27 = 1e27;\nuint256 constant BASE_36 = 1e36;\nuint256 constant MAX_BURN_FEE = 999_000_000;\nuint256 constant MAX_MINT_FEE = BASE_12 - 1;\n\n/*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                     REENTRANT                                                      \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n// The values being non-zero value makes deployment a bit more expensive,\n// but in exchange the refund on every call to nonReentrant will be lower in\n// amount. Since refunds are capped to a percentage of the total\n// transaction's gas, it is best to keep them low in cases like this one, to\n// increase the likelihood of the full refund coming into effect.\nuint8 constant NOT_ENTERED = 1;\nuint8 constant ENTERED = 2;\n\n/*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                               COMMON ADDRESSES                                                 \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\naddress constant PERMIT_2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;\naddress constant ONE_INCH_ROUTER = 0x1111111254EEB25477B68fb85Ed929f73A960582;\naddress constant AGEUR = 0x1a7e4e63778B4f12a199C062f3eFdD288afCBce8;\nICbETH constant CBETH = ICbETH(0xBe9895146f7AF43049ca1c1AE358B0541Ea49704);\nIRETH constant RETH = IRETH(0xae78736Cd615f374D3085123A210448E74Fc6393);\nIStETH constant STETH = IStETH(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);\nISfrxETH constant SFRXETH = ISfrxETH(0xac3E018457B222d93114458476f3E3416Abbe38F);\n"},"contracts/utils/Errors.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nerror AlreadyAdded();\nerror CannotAddFunctionToDiamondThatAlreadyExists(bytes4 _selector);\nerror CannotAddSelectorsToZeroAddress(bytes4[] _selectors);\nerror CannotRemoveFunctionThatDoesNotExist(bytes4 _selector);\nerror CannotRemoveImmutableFunction(bytes4 _selector);\nerror CannotReplaceFunctionsFromFacetWithZeroAddress(bytes4[] _selectors);\nerror CannotReplaceFunctionThatDoesNotExists(bytes4 _selector);\nerror CannotReplaceFunctionWithTheSameFunctionFromTheSameFacet(bytes4 _selector);\nerror CannotReplaceImmutableFunction(bytes4 _selector);\nerror ContractHasNoCode();\nerror FunctionNotFound(bytes4 _functionSelector);\nerror IncorrectFacetCutAction(uint8 _action);\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\nerror InvalidChainlinkRate();\nerror InvalidLengths();\nerror InvalidNegativeFees();\nerror InvalidOracleType();\nerror InvalidParam();\nerror InvalidParams();\nerror InvalidSwap();\nerror InvalidTokens();\nerror ManagerHasAssets();\nerror NoSelectorsProvidedForFacetForCut(address _facetAddress);\nerror NotAllowed();\nerror NotCollateral();\nerror NotGovernor();\nerror NotGovernorOrGuardian();\nerror NotTrusted();\nerror NotWhitelisted();\nerror OneInchSwapFailed();\nerror Paused();\nerror ReentrantCall();\nerror RemoveFacetAddressMustBeZeroAddress(address _facetAddress);\nerror TooBigAmountIn();\nerror TooLate();\nerror TooSmallAmountOut();\nerror ZeroAddress();\nerror ZeroAmount();\n"},"contracts/transmuter/Storage.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { IERC20 } from \"oz/token/ERC20/IERC20.sol\";\n\nimport { IAccessControlManager } from \"interfaces/IAccessControlManager.sol\";\nimport { IAgToken } from \"interfaces/IAgToken.sol\";\n\n/*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                        ENUMS                                                      \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\nenum FacetCutAction {\n    Add,\n    Replace,\n    Remove\n}\n\nenum ManagerType {\n    EXTERNAL\n}\n\nenum ActionType {\n    Mint,\n    Burn,\n    Redeem\n}\n\nenum TrustedType {\n    Updater,\n    Seller\n}\n\nenum QuoteType {\n    MintExactInput,\n    MintExactOutput,\n    BurnExactInput,\n    BurnExactOutput\n}\n\nenum OracleReadType {\n    CHAINLINK_FEEDS,\n    EXTERNAL,\n    NO_ORACLE,\n    STABLE,\n    WSTETH,\n    CBETH,\n    RETH,\n    SFRXETH\n}\n\nenum OracleQuoteType {\n    UNIT,\n    TARGET\n}\n\nenum WhitelistType {\n    BACKED\n}\n\n/*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    STRUCTS                                                     \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\nstruct Permit2Details {\n    address to;                                  // Address that will receive the funds\n    uint256 nonce;                               // Nonce of the transaction\n    bytes signature;                             // Permit signature of the user\n}       \n\nstruct FacetCut {\n    address facetAddress;                        // Facet contract address\n    FacetCutAction action;                       // Can be add, remove or replace\n    bytes4[] functionSelectors;                  // Ex. bytes4(keccak256(\"transfer(address,uint256)\"))\n}\n\nstruct Facet {\n    address facetAddress;                        // Facet contract address\n    bytes4[] functionSelectors;                  // Ex. bytes4(keccak256(\"transfer(address,uint256)\"))\n}\n\nstruct FacetInfo {\n    address facetAddress;                        // Facet contract address\n    uint16 selectorPosition;                     // Position in the list of all selectors\n}\n\nstruct DiamondStorage {\n    bytes4[] selectors;                          // List of all available selectors\n    mapping(bytes4 => FacetInfo) selectorInfo;   // Selector to (address, position in list)\n    IAccessControlManager accessControlManager;  // Contract handling access control\n}\n\nstruct ImplementationStorage {\n    address implementation;                      // Dummy implementation address for Etherscan usability\n}\n\nstruct ManagerStorage {\n    IERC20[] subCollaterals;                     // Subtokens handled by the manager or strategies\n    bytes config;                                // Additional configuration data\n}\n\nstruct Collateral {\n    uint8 isManaged;                             // If the collateral is managed through external strategies\n    uint8 isMintLive;                            // If minting from this asset is unpaused\n    uint8 isBurnLive;                            // If burning to this asset is unpaused\n    uint8 decimals;                              // IERC20Metadata(collateral).decimals()\n    uint8 onlyWhitelisted;                       // If only whitelisted addresses can burn or redeem for this token\n    uint216 normalizedStables;                   // Normalized amount of stablecoins issued from this collateral\n    uint64[] xFeeMint;                           // Increasing exposures in [0,BASE_9[\n    int64[] yFeeMint;                            // Mint fees at the exposures specified in `xFeeMint`\n    uint64[] xFeeBurn;                           // Decreasing exposures in ]0,BASE_9]\n    int64[] yFeeBurn;                            // Burn fees at the exposures specified in `xFeeBurn`\n    bytes oracleConfig;                          // Data about the oracle used for the collateral\n    bytes whitelistData;                         // For whitelisted collateral, data used to verify whitelists\n    ManagerStorage managerData;                  // For managed collateral, data used to handle the strategies\n}\n\nstruct TransmuterStorage {\n    IAgToken agToken;                            // agToken handled by the system\n    uint8 isRedemptionLive;                      // If redemption is unpaused\n    uint8 statusReentrant;                        // If call is reentrant or not\n    uint128 normalizedStables;                   // Normalized amount of stablecoins issued by the system\n    uint128 normalizer;                          // To reconcile `normalizedStables` values with the actual amount\n    address[] collateralList;                    // List of collateral assets supported by the system\n    uint64[] xRedemptionCurve;                   // Increasing collateral ratios > 0\n    int64[] yRedemptionCurve;                    // Value of the redemption fees at `xRedemptionCurve`\n    mapping(address => Collateral) collaterals;  // Maps a collateral asset to its parameters\n    mapping(address => uint256) isTrusted;       // If an address is trusted to update the normalizer value\n    mapping(address => uint256) isSellerTrusted; // If an address is trusted to sell accruing reward tokens\n    mapping(WhitelistType => mapping(address => uint256)) isWhitelistedForType;\n                                                 // Whether an address is whitelisted for a specific whitelist type\n}\n"},"node_modules/@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"},"node_modules/@openzeppelin/contracts/utils/Address.sol":{"content":"// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"},"contracts/transmuter/libraries/LibOracle.sol":{"content":"// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.19;\n\nimport { ITransmuterOracle } from \"interfaces/ITransmuterOracle.sol\";\nimport { AggregatorV3Interface } from \"interfaces/external/chainlink/AggregatorV3Interface.sol\";\n\nimport { LibStorage as s } from \"./LibStorage.sol\";\n\nimport \"../../utils/Constants.sol\";\nimport \"../../utils/Errors.sol\";\nimport \"../Storage.sol\";\n\n/// @title LibOracle\n/// @author Angle Labs, Inc.\nlibrary LibOracle {\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                               ACTIONS SPECIFIC ORACLES                                             \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Reads the oracle value used during a redemption to compute collateral ratio for `oracleConfig`\n    /// @dev This value is only sensitive to compute the collateral ratio and deduce a penalty factor\n    function readRedemption(bytes memory oracleConfig) internal view returns (uint256) {\n        (\n            OracleReadType oracleType,\n            OracleReadType targetType,\n            bytes memory oracleData,\n            bytes memory targetData\n        ) = _parseOracleConfig(oracleConfig);\n        if (oracleType == OracleReadType.EXTERNAL) {\n            ITransmuterOracle externalOracle = abi.decode(oracleData, (ITransmuterOracle));\n            return externalOracle.readRedemption();\n        } else return read(oracleType, read(targetType, BASE_18, targetData), oracleData);\n    }\n\n    /// @notice Reads the oracle value used during mint operations for an asset with `oracleConfig`\n    /// @dev For assets which do not rely on external oracles, this value is the minimum between the asset oracle\n    /// value and its target price\n    function readMint(bytes memory oracleConfig) internal view returns (uint256 oracleValue) {\n        (\n            OracleReadType oracleType,\n            OracleReadType targetType,\n            bytes memory oracleData,\n            bytes memory targetData\n        ) = _parseOracleConfig(oracleConfig);\n        if (oracleType == OracleReadType.EXTERNAL) {\n            ITransmuterOracle externalOracle = abi.decode(oracleData, (ITransmuterOracle));\n            return externalOracle.readMint();\n        }\n        uint256 _targetPrice = read(targetType, BASE_18, targetData);\n        oracleValue = read(oracleType, _targetPrice, oracleData);\n        if (_targetPrice < oracleValue) oracleValue = _targetPrice;\n    }\n\n    /// @notice Reads the oracle value that will be used for a burn operation for an asset with `oracleConfig`\n    /// @return oracleValue The actual oracle value obtained\n    /// @return ratio If `oracle value < target price`, the ratio between the oracle value and the target\n    /// price, otherwise `BASE_18`\n    function readBurn(bytes memory oracleConfig) internal view returns (uint256 oracleValue, uint256 ratio) {\n        (\n            OracleReadType oracleType,\n            OracleReadType targetType,\n            bytes memory oracleData,\n            bytes memory targetData\n        ) = _parseOracleConfig(oracleConfig);\n        if (oracleType == OracleReadType.EXTERNAL) {\n            ITransmuterOracle externalOracle = abi.decode(oracleData, (ITransmuterOracle));\n            return externalOracle.readBurn();\n        }\n        uint256 _targetPrice = read(targetType, BASE_18, targetData);\n        oracleValue = read(oracleType, _targetPrice, oracleData);\n        ratio = BASE_18;\n        if (oracleValue < _targetPrice) ratio = (oracleValue * BASE_18) / _targetPrice;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                    VIEW FUNCTIONS                                                  \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Internal version of the `getOracle` function\n    function getOracle(\n        address collateral\n    ) internal view returns (OracleReadType, OracleReadType, bytes memory, bytes memory) {\n        return _parseOracleConfig(s.transmuterStorage().collaterals[collateral].oracleConfig);\n    }\n\n    /// @notice Gets the oracle value and the ratio with respect to the target price when it comes to\n    /// burning for `collateral`\n    function getBurnOracle(\n        address collateral,\n        bytes memory oracleConfig\n    ) internal view returns (uint256 minRatio, uint256 oracleValue) {\n        TransmuterStorage storage ts = s.transmuterStorage();\n        minRatio = BASE_18;\n        address[] memory collateralList = ts.collateralList;\n        uint256 length = collateralList.length;\n        for (uint256 i; i < length; ++i) {\n            uint256 ratioObserved = BASE_18;\n            if (collateralList[i] != collateral) {\n                (, ratioObserved) = readBurn(ts.collaterals[collateralList[i]].oracleConfig);\n            } else (oracleValue, ratioObserved) = readBurn(oracleConfig);\n            if (ratioObserved < minRatio) minRatio = ratioObserved;\n        }\n    }\n\n    /// @notice Computes the `quoteAmount` (for Chainlink oracles) depending on a `quoteType` and a base value\n    /// (e.g the target price of the asset)\n    /// @dev For cases where the Chainlink feed directly looks into the value of the asset, `quoteAmount` is `BASE_18`.\n    /// For others, like wstETH for which Chainlink only has an oracle for stETH, `quoteAmount` is the target price\n    function quoteAmount(OracleQuoteType quoteType, uint256 baseValue) internal pure returns (uint256) {\n        if (quoteType == OracleQuoteType.UNIT) return BASE_18;\n        else return baseValue;\n    }\n\n    /// @notice Reads an oracle value (or a target oracle value) for an asset based on its data parsed `oracleConfig`\n    function read(OracleReadType readType, uint256 baseValue, bytes memory data) internal view returns (uint256) {\n        if (readType == OracleReadType.CHAINLINK_FEEDS) {\n            (\n                AggregatorV3Interface[] memory circuitChainlink,\n                uint32[] memory stalePeriods,\n                uint8[] memory circuitChainIsMultiplied,\n                uint8[] memory chainlinkDecimals,\n                OracleQuoteType quoteType\n            ) = abi.decode(data, (AggregatorV3Interface[], uint32[], uint8[], uint8[], OracleQuoteType));\n            uint256 quotePrice = quoteAmount(quoteType, baseValue);\n            uint256 listLength = circuitChainlink.length;\n            for (uint256 i; i < listLength; ++i) {\n                quotePrice = readChainlinkFeed(\n                    quotePrice,\n                    circuitChainlink[i],\n                    circuitChainIsMultiplied[i],\n                    chainlinkDecimals[i],\n                    stalePeriods[i]\n                );\n            }\n            return quotePrice;\n        } else if (readType == OracleReadType.STABLE) return BASE_18;\n        else if (readType == OracleReadType.NO_ORACLE) return baseValue;\n        else if (readType == OracleReadType.WSTETH) return STETH.getPooledEthByShares(1 ether);\n        else if (readType == OracleReadType.CBETH) return CBETH.exchangeRate();\n        else if (readType == OracleReadType.RETH) return RETH.getExchangeRate();\n        else if (readType == OracleReadType.SFRXETH) return SFRXETH.pricePerShare();\n        // If the `OracleReadType` is `EXTERNAL`, it means that this function is called to compute a\n        // `targetPrice` in which case the `baseValue` is returned here\n        else return baseValue;\n    }\n\n    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                   SPECIFIC HELPERS                                                 \n    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////*/\n\n    /// @notice Reads a Chainlink feed using a quote amount and converts the quote amount to\n    /// the out-currency\n    /// @param _quoteAmount The amount for which to compute the price expressed in `BASE_18`\n    /// @param feed Chainlink feed to query\n    /// @param multiplied Whether the ratio outputted by Chainlink should be multiplied or divided\n    /// to the `quoteAmount`\n    /// @param decimals Number of decimals of the corresponding Chainlink pair\n    /// @return The `quoteAmount` converted in out-currency\n    function readChainlinkFeed(\n        uint256 _quoteAmount,\n        AggregatorV3Interface feed,\n        uint8 multiplied,\n        uint256 decimals,\n        uint32 stalePeriod\n    ) internal view returns (uint256) {\n        (, int256 ratio, , uint256 updatedAt, ) = feed.latestRoundData();\n        if (ratio <= 0 || block.timestamp - updatedAt > stalePeriod) revert InvalidChainlinkRate();\n        // Checking whether we should multiply or divide by the ratio computed\n        if (multiplied == 1) return (_quoteAmount * uint256(ratio)) / (10 ** decimals);\n        else return (_quoteAmount * (10 ** decimals)) / uint256(ratio);\n    }\n\n    /// @notice Parses an `oracleConfig` into several sub fields\n    function _parseOracleConfig(\n        bytes memory oracleConfig\n    ) private pure returns (OracleReadType, OracleReadType, bytes memory, bytes memory) {\n        return abi.decode(oracleConfig, (OracleReadType, OracleReadType, bytes, bytes));\n    }\n}\n"},"contracts/interfaces/IManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\n/// @title IManager\n/// @author Angle Labs, Inc.\ninterface IManager {\n    /// @notice Returns the amount of collateral managed by the Manager\n    /// @return balances Balances of all the subCollaterals handled by the manager\n    /// @dev MUST NOT revert\n    function totalAssets() external view returns (uint256[] memory balances, uint256 totalValue);\n\n    /// @notice Hook to invest `amount` of `collateral`\n    /// @dev MUST revert if the manager cannot accept these funds\n    /// @dev MUST have received the funds beforehand\n    function invest(uint256 amount) external;\n\n    /// @notice Sends `amount` of `collateral` to the `to` address\n    /// @dev Called when `agToken` are burnt and during redemptions\n    //  @dev MUST revert if there are not funds enough available\n    /// @dev MUST be callable only by the transmuter\n    function release(address asset, address to, uint256 amount) external;\n\n    /// @notice Gives the maximum amount of collateral immediately available for a transfer\n    /// @dev Useful for integrators using `quoteIn` and `quoteOut`\n    function maxAvailable() external view returns (uint256);\n}\n"},"contracts/interfaces/external/keyring/IKeyringGuard.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\n/// @title IKeyringGuard\n/// @notice Interface for the `KeyringGuard` contract\ninterface IKeyringGuard {\n    function isAuthorized(address from, address to) external returns (bool passed);\n}\n"},"contracts/interfaces/external/coinbase/ICbETH.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\n/// @title ICbETH\n/// @notice Interface for the `cbETH` contract\ninterface ICbETH {\n    function exchangeRate() external view returns (uint256);\n}\n"},"contracts/interfaces/external/frax/ISfrxETH.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\n/// @title ISfrxETH\n/// @notice Interface for the `sfrxETH` contract\ninterface ISfrxETH {\n    function pricePerShare() external view returns (uint256);\n}\n"},"contracts/interfaces/external/lido/IStETH.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\n/// @title IStETH\n/// @notice Interface for the `StETH` contract\ninterface IStETH {\n    function getPooledEthByShares(uint256 _sharesAmount) external view returns (uint256);\n\n    function submit(address) external payable returns (uint256);\n\n    function getSharesByPooledEth(uint256 _ethAmount) external view returns (uint256);\n}\n"},"contracts/interfaces/external/rocketPool/IRETH.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\n/// @title IRETH\n/// @notice Interface for the `rETH` contract\ninterface IRETH {\n    function getExchangeRate() external view returns (uint256);\n}\n"},"contracts/interfaces/IAccessControlManager.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\n/// @title IAccessControlManager\n/// @author Angle Labs, Inc.\ninterface IAccessControlManager {\n    /// @notice Checks whether an address is governor of the Angle Protocol or not\n    /// @param admin Address to check\n    /// @return Whether the address has the `GOVERNOR_ROLE` or not\n    function isGovernor(address admin) external view returns (bool);\n\n    /// @notice Checks whether an address is governor or a guardian of the Angle Protocol or not\n    /// @param admin Address to check\n    /// @return Whether the address has the `GUARDIAN_ROLE` or not\n    /// @dev Governance should make sure when adding a governor to also give this governor the guardian\n    /// role by calling the `addGovernor` function\n    function isGovernorOrGuardian(address admin) external view returns (bool);\n}\n"},"contracts/interfaces/ITransmuterOracle.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\n/// @title ITransmuterOracle\n/// @author Angle Labs, Inc.\ninterface ITransmuterOracle {\n    /// @notice Reads the oracle value for asset to use in a redemption to compute the collateral ratio\n    function readRedemption() external view returns (uint256);\n\n    /// @notice Reads the oracle value for asset to use in a mint. It should be comprehensive of the\n    /// deviation from the target price\n    function readMint() external view returns (uint256);\n\n    /// @notice Reads the oracle value for asset to use in a burn transaction as well as the ratio\n    /// between the current price and the target price for the asset\n    function readBurn() external view returns (uint256 oracleValue, uint256 ratio);\n}\n"},"contracts/interfaces/external/chainlink/AggregatorV3Interface.sol":{"content":"// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(\n        uint80 _roundId\n    )\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n    function latestRoundData()\n        external\n        view\n        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"}},"settings":{"remappings":["@chainlink/=lib/borrow-contracts/node_modules/@chainlink/","@ensdomains/=node_modules/@ensdomains/","@openzeppelin/=node_modules/@openzeppelin/","@prb/test/=lib/prb-math/lib/prb-test/src/","@uniswap/=lib/borrow-contracts/node_modules/@uniswap/","borrow-contracts/=lib/borrow-contracts/","borrow/=lib/borrow-contracts/contracts/","contracts/=contracts/","ds-test/=lib/forge-std/lib/ds-test/src/","forge-std/=lib/forge-std/src/","interfaces/=contracts/interfaces/","mock/=test/mock/","oz-upgradeable/=node_modules/@openzeppelin/contracts-upgradeable/","oz/=node_modules/@openzeppelin/contracts/","prb-math/=lib/prb-math/src/","prb-test/=lib/prb-math/lib/prb-test/src/","prb/math/=lib/prb-math/src/","solidity-stringutils/=lib/solidity-stringutils/","src/=lib/prb-math/src/","stringutils/=lib/solidity-stringutils/","test/=test/"],"optimizer":{"enabled":true,"runs":5000},"metadata":{"bytecodeHash":"ipfs","appendCBOR":true},"outputSelection":{"*":{"":["ast"],"*":["abi","evm.bytecode","evm.deployedBytecode","evm.methodIdentifiers","metadata"]}},"evmVersion":"paris","viaIR":true,"libraries":{}}}
